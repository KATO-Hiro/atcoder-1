# 精進ノート

## デバッグメモ

- C++ 仕様と実装全般
    - スコープ内外で名前衝突
        - グローバルとローカル
        - ある関数直下とその中の `{}` の中
    - オーバーフロー
    - iterator 理解ミス
        - lower_bound, upper_bound
        - rbegin, rend
    - 使用変数のミス
        - 入力時に `M` 回受け取るところで `N` 回にしてしまってる
        - `i` とすべきところで `j` にしている
    - sort のし忘れ
    - sort の降順・昇順ミス（`SORT` じゃなくて `RSORT`）
    - 符号ミス（マイナスつけ忘れ，引き算順序ミスなど）
    - 番兵
        - 足りない（2種類必要なケースもある．Lazy Faith とか）
        - 値が悪い
            - 番兵の役割を十分果たせる値を設定する
            - オーバーフローしないか？ INF でマズそうなら制約から決める
    - multiset
        - 誤って set を使っている
        - 1要素だけ削除したいのに同じ値の要素を全削除している
- 競プロ系
    - 初期化ミス（DP など）
    - コーナーケース
        - 0 の場合
        - 1 の場合
        - 2 の場合
    - 出力形式ミス
        - 構築系なら最初にサイズを出力するかどうか
    - 0-based, 1-based のミス
    - 有向グラフ・無向グラフのミス
    - ループ範囲ミス
        - `FOR(i,1,N+1)` が `FOR(i,1,N)` になっている
        - `REP(i,1<<N)` が `REP(i,N)` になっている

## 典型考察メモ

- 全般
    - 単調性のある最小化/最大化問題は "決め打ち二分探索" [[link](https://betrue12.hateblo.jp/entry/2019/05/11/013403)]
    - 区間は「累積和」「セグメント木」「DP」「尺取り」で考える
    - 「必ず○○する□□をすべて求めよ（○○＝使う・通る等）」
        - 各□□を一時的に無効にして成立するか評価することで各□□が必要か判定できる
    - 絶対値は ± で全探索を検討

- DP
    - 貰う DP は累積和で高速化できる可能性がある
    - 配る DP はインライン DP が使える可能性がある
    - unordered_set 配列より bool 配列の方が高速 (値の範囲が狭い場合) [[abc147_e](https://atcoder.jp/contests/abc147/tasks/abc147_e)]
    - 桁DP
        - `dp[先頭からi桁目][N未満確定フラグ][条件]` [[link](https://torus711.hatenablog.com/entry/20150423/1429794075)] [[link](https://www.hamayanhamayan.com/entry/2017/04/23/212728)]
        - 整数は `y = 10 * x + d` の繰り返しで計算可能 [[link](https://drken1215.hatenablog.com/entry/2020/04/23/194600)]

- グラフ
    - 順序付きの集合は DAG で扱える（順序付けされているものを頂点に乗せる）
        - DAG は DP が使える（最短経路問題など）
    - 最短経路問題などを解いた結果を用いて別のグラフを構築して解くケースがある
    - 条件式がたくさんあり芋づる式に確定していく問題はグラフで考える

- 貪欲
    - スケジューリングは前から貪欲に考える
    - 計算量解析すると実は貪欲で間に合うケースがある [[agc014_a](https://atcoder.jp/contests/agc014/tasks/agc014_a)]

- 数え上げ
    - 主客転倒テク：すべての組み合わせのコスト総和を計算する場合，ある1つの組み合わせにおけるコストを要素毎に分解して，各要素が題意に与える寄与を独立に計算して数え上げる
    - 数え上げは DP の可能性が高い
    - 愚直な DP を考えてから高速化を考える（累積和など）

- ゲーム
    - 後退解析 + メモ化再帰 によるゲーム DP (状態数オーダーに注意)
    - Grundy 数
    - 不変量
    - adhoc, O(1)
    - 考察ネタ
        - パリティを考える (操作回数のパリティ等)
        - 初期配置のパターンで場合分けする
        - 勝利確定パターンを探す
        - 終了局面に何か特徴がないか考える
        - 最終手段は実験 (ノート・愚直コード)

- 操作系
    - 不変量に着目する（全体の総和など）

- XOR
    - `0〜N` の XOR は `mod 4` で場合分け可能 [[link](https://www.hamayanhamayan.com/entry/2017/05/20/145021)] [[link](http://kyopro.hateblo.jp/entry/2019/05/22/054412)]

---

以下は一応残してるだけ

## C++ (GCC 9.2.1)

- `next_permutation()` は対象が昇順ソート済みでないと順列が全列挙されない
- `double` 型の値を出力する際は表示桁数を増やさないと精度低下する [[link](https://atcoder.jp/contests/apg4b/tasks/APG4b_y)]
- `string` 型は終端文字 `'\0'` が入っているため，range-for などで注意が必要
- `boost/multiprecision` を使えば C++ でも多倍長整数が使える

## Numba (0.48.0)

主に Numba くんの悪口

- **Numba のここがすごい**
    - Python を手軽に高速化できる！

- **Numba のここがダメ**
    - エラーメッセージが死ぬほど分かりにくい
    - `TypedList` の配列アクセスが激遅（隣接リストが絶望的）
    - `collections` が使えない
        - `Counter`, `deque`
    - `itertools` が使えない
        - `combinations`, `combinations_with_replacement`, `permutations`, `product`
    - `pow` が使えない
    - `set()` が使えない
